'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraphQLWatchman = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _fbWatchman = require('fb-watchman');

var _fbWatchman2 = _interopRequireDefault(_fbWatchman);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  Copyright (c) Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the license found in the
 *  LICENSE file in the root directory of this source tree.
 *
 *  
 */

var GraphQLWatchman = exports.GraphQLWatchman = function () {
  function GraphQLWatchman() {
    _classCallCheck(this, GraphQLWatchman);

    this._client = new _fbWatchman2.default.Client();
  }

  GraphQLWatchman.prototype.checkVersion = function checkVersion() {
    var _this = this;

    return new Promise(function (resolve, reject) {
      _this._client.capabilityCheck({
        optional: [],
        required: ['cmd-watch-project']
      }, function (error, response) {
        if (error) {
          reject(error);
        } else {
          // From the Watchman docs, response is something like:
          // {'version': '3.8.0', 'capabilities': {'relative_root': true}}.
          resolve();
        }
      });
      _this._client.on('error', reject);
    });
  };

  GraphQLWatchman.prototype.listFiles = function listFiles(entryPath) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var _ref, watch, relative_path, result;

    return regeneratorRuntime.async(function listFiles$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return regeneratorRuntime.awrap(this.watchProject(entryPath));

          case 2:
            _ref = _context.sent;
            watch = _ref.watch;
            relative_path = _ref.relative_path;
            _context.next = 7;
            return regeneratorRuntime.awrap(this.runCommand('query', watch, _extends({
              expression: ['allof', ['type', 'f'], ['anyof', ['match', '*.graphql'], ['match', '*.js']], ['not', ['dirname', 'generated/relay']], ['not', ['match', '**/__flow__/**', 'wholename']], ['not', ['match', '**/__generated__/**', 'wholename']], ['not', ['match', '**/__github__/**', 'wholename']], ['not', ['match', '**/__mocks__/**', 'wholename']], ['not', ['match', '**/node_modules/**', 'wholename']], ['not', ['match', '**/__flowtests__/**', 'wholename']], ['exists']],
              // Providing `path` will let watchman use path generator, and will perform
              // a tree walk with respect to the relative_root and path provided.
              // Path generator will do less work unless the root path of the repository
              // is passed in as an entry path.
              fields: ['name', 'size', 'mtime'],
              relative_root: relative_path
            }, options)));

          case 7:
            result = _context.sent;
            return _context.abrupt('return', result.files);

          case 9:
          case 'end':
            return _context.stop();
        }
      }
    }, null, this);
  };

  GraphQLWatchman.prototype.runCommand = function runCommand() {
    var _this2 = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Promise(function (resolve, reject) {
      return _this2._client.command(args, function (error, response) {
        if (error) {
          reject(error);
        }
        resolve(response);
      });
    }).catch(function (error) {
      throw new Error(error);
    });
  };

  GraphQLWatchman.prototype.watchProject = function watchProject(directoryPath) {
    var response;
    return regeneratorRuntime.async(function watchProject$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return regeneratorRuntime.awrap(this.runCommand('watch-project', directoryPath));

          case 3:
            response = _context2.sent;
            return _context2.abrupt('return', response);

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2['catch'](0);
            throw new Error(_context2.t0);

          case 10:
          case 'end':
            return _context2.stop();
        }
      }
    }, null, this, [[0, 7]]);
  };

  GraphQLWatchman.prototype.subscribe = function subscribe(entryPath, callback) {
    var _ref2, watch, relative_path;

    return regeneratorRuntime.async(function subscribe$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return regeneratorRuntime.awrap(this.watchProject(entryPath));

          case 2:
            _ref2 = _context3.sent;
            watch = _ref2.watch;
            relative_path = _ref2.relative_path;
            _context3.next = 7;
            return regeneratorRuntime.awrap(this.runCommand('subscribe', watch, relative_path || watch, {
              expression: ['allof', ['match', '*.graphql']],
              fields: ['name', 'exists', 'size', 'mtime'],
              relative_root: relative_path
            }));

          case 7:

            this._client.on('subscription', function (result) {
              if (result.subscription !== relative_path) {
                return;
              }
              callback(result);
            });

          case 8:
          case 'end':
            return _context3.stop();
        }
      }
    }, null, this);
  };

  GraphQLWatchman.prototype.dispose = function dispose() {
    this._client.end();
    this._client = null;
  };

  return GraphQLWatchman;
}();