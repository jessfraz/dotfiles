"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGraphQLCache = getGraphQLCache;
exports.GraphQLCache = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _graphql = require("graphql");

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _graphqlConfig = require("graphql-config");

var _MessageProcessor = require("./MessageProcessor");

var _stringToHash = _interopRequireDefault(require("./stringToHash"));

var _glob = _interopRequireDefault(require("glob"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Maximum files to read when processing GraphQL files.
const MAX_READS = 200;
const {
  DOCUMENT,
  FRAGMENT_DEFINITION,
  OBJECT_TYPE_DEFINITION,
  INTERFACE_TYPE_DEFINITION,
  ENUM_TYPE_DEFINITION,
  UNION_TYPE_DEFINITION,
  SCALAR_TYPE_DEFINITION,
  INPUT_OBJECT_TYPE_DEFINITION,
  SCALAR_TYPE_EXTENSION,
  OBJECT_TYPE_EXTENSION,
  INTERFACE_TYPE_EXTENSION,
  UNION_TYPE_EXTENSION,
  ENUM_TYPE_EXTENSION,
  INPUT_OBJECT_TYPE_EXTENSION,
  DIRECTIVE_DEFINITION
} = _graphql.Kind;

async function getGraphQLCache(configDir) {
  const graphQLConfig = await (0, _graphqlConfig.getGraphQLConfig)(configDir);
  return new GraphQLCache(configDir, graphQLConfig);
}

class GraphQLCache {
  constructor(configDir, graphQLConfig) {
    _defineProperty(this, "_configDir", void 0);

    _defineProperty(this, "_graphQLFileListCache", void 0);

    _defineProperty(this, "_graphQLConfig", void 0);

    _defineProperty(this, "_cachePromise", void 0);

    _defineProperty(this, "_schemaMap", void 0);

    _defineProperty(this, "_typeExtensionMap", void 0);

    _defineProperty(this, "_fragmentDefinitionsCache", void 0);

    _defineProperty(this, "_typeDefinitionsCache", void 0);

    _defineProperty(this, "getGraphQLConfig", () => this._graphQLConfig);

    _defineProperty(this, "getFragmentDependencies", async (query, fragmentDefinitions) => {
      // If there isn't context for fragment references,
      // return an empty array.
      if (!fragmentDefinitions) {
        return [];
      } // If the query cannot be parsed, validations cannot happen yet.
      // Return an empty array.


      let parsedQuery;

      try {
        parsedQuery = (0, _graphql.parse)(query, {
          allowLegacySDLImplementsInterfaces: true,
          allowLegacySDLEmptyFields: true
        });
      } catch (error) {
        return [];
      }

      return this.getFragmentDependenciesForAST(parsedQuery, fragmentDefinitions);
    });

    _defineProperty(this, "getFragmentDependenciesForAST", async (parsedQuery, fragmentDefinitions) => {
      if (!fragmentDefinitions) {
        return [];
      }

      const existingFrags = new Map();
      const referencedFragNames = new Set();
      (0, _graphql.visit)(parsedQuery, {
        FragmentDefinition(node) {
          existingFrags.set(node.name.value, true);
        },

        FragmentSpread(node) {
          if (!referencedFragNames.has(node.name.value)) {
            referencedFragNames.add(node.name.value);
          }
        }

      });
      const asts = new Set();
      referencedFragNames.forEach(name => {
        if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {
          asts.add((0, _nullthrows.default)(fragmentDefinitions.get(name)));
        }
      });
      const referencedFragments = [];
      asts.forEach(ast => {
        (0, _graphql.visit)(ast.definition, {
          FragmentSpread(node) {
            if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
              asts.add((0, _nullthrows.default)(fragmentDefinitions.get(node.name.value)));
              referencedFragNames.add(node.name.value);
            }
          }

        });

        if (!existingFrags.has(ast.definition.name.value)) {
          referencedFragments.push(ast);
        }
      });
      return referencedFragments;
    });

    _defineProperty(this, "getFragmentDefinitions", async projectConfig => {
      // This function may be called from other classes.
      // If then, check the cache first.
      const rootDir = projectConfig.configDir;

      if (this._fragmentDefinitionsCache.has(rootDir)) {
        return this._fragmentDefinitionsCache.get(rootDir) || new Map();
      }

      const filesFromInputDirs = await this._readFilesFromInputDirs(rootDir, projectConfig.includes);
      const list = filesFromInputDirs.filter(fileInfo => projectConfig.includesFile(fileInfo.filePath));
      const {
        fragmentDefinitions,
        graphQLFileMap
      } = await this.readAllGraphQLFiles(list);

      this._fragmentDefinitionsCache.set(rootDir, fragmentDefinitions);

      this._graphQLFileListCache.set(rootDir, graphQLFileMap);

      return fragmentDefinitions;
    });

    _defineProperty(this, "getObjectTypeDependencies", async (query, objectTypeDefinitions) => {
      // If there isn't context for object type references,
      // return an empty array.
      if (!objectTypeDefinitions) {
        return [];
      } // If the query cannot be parsed, validations cannot happen yet.
      // Return an empty array.


      let parsedQuery;

      try {
        parsedQuery = (0, _graphql.parse)(query, {
          allowLegacySDLImplementsInterfaces: true,
          allowLegacySDLEmptyFields: true
        });
      } catch (error) {
        return [];
      }

      return this.getObjectTypeDependenciesForAST(parsedQuery, objectTypeDefinitions);
    });

    _defineProperty(this, "getObjectTypeDependenciesForAST", async (parsedQuery, objectTypeDefinitions) => {
      if (!objectTypeDefinitions) {
        return [];
      }

      const existingObjectTypes = new Map();
      const referencedObjectTypes = new Set();
      (0, _graphql.visit)(parsedQuery, {
        ObjectTypeDefinition(node) {
          existingObjectTypes.set(node.name.value, true);
        },

        InputObjectTypeDefinition(node) {
          existingObjectTypes.set(node.name.value, true);
        },

        EnumTypeDefinition(node) {
          existingObjectTypes.set(node.name.value, true);
        },

        NamedType(node) {
          if (!referencedObjectTypes.has(node.name.value)) {
            referencedObjectTypes.add(node.name.value);
          }
        }

      });
      const asts = new Set();
      referencedObjectTypes.forEach(name => {
        if (!existingObjectTypes.has(name) && objectTypeDefinitions.has(name)) {
          asts.add((0, _nullthrows.default)(objectTypeDefinitions.get(name)));
        }
      });
      const referencedObjects = [];
      asts.forEach(ast => {
        (0, _graphql.visit)(ast.definition, {
          NamedType(node) {
            if (!referencedObjectTypes.has(node.name.value) && objectTypeDefinitions.get(node.name.value)) {
              asts.add((0, _nullthrows.default)(objectTypeDefinitions.get(node.name.value)));
              referencedObjectTypes.add(node.name.value);
            }
          }

        });

        if (!existingObjectTypes.has(ast.definition.name.value)) {
          referencedObjects.push(ast);
        }
      });
      return referencedObjects;
    });

    _defineProperty(this, "getObjectTypeDefinitions", async projectConfig => {
      // This function may be called from other classes.
      // If then, check the cache first.
      const rootDir = projectConfig.configDir;

      if (this._typeDefinitionsCache.has(rootDir)) {
        return this._typeDefinitionsCache.get(rootDir) || new Map();
      }

      const filesFromInputDirs = await this._readFilesFromInputDirs(rootDir, projectConfig.includes);
      const list = filesFromInputDirs.filter(fileInfo => projectConfig.includesFile(fileInfo.filePath));
      const {
        objectTypeDefinitions,
        graphQLFileMap
      } = await this.readAllGraphQLFiles(list);

      this._typeDefinitionsCache.set(rootDir, objectTypeDefinitions);

      this._graphQLFileListCache.set(rootDir, graphQLFileMap);

      return objectTypeDefinitions;
    });

    _defineProperty(this, "handleWatchmanSubscribeEvent", (rootDir, projectConfig) => result => {
      if (result.files && result.files.length > 0) {
        const graphQLFileMap = this._graphQLFileListCache.get(rootDir);

        result.files.forEach(async ({
          name,
          exists,
          size,
          mtime
        }) => {
          const filePath = _path.default.join(result.root, result.subscription, name);

          if (projectConfig.schemaPath && filePath === projectConfig.schemaPath) {
            this._invalidateSchemaCacheForProject(projectConfig);
          }

          if (!graphQLFileMap) {
            return;
          } // Prune the file using the input/excluded directories


          if (!projectConfig.includesFile(name)) {
            return;
          } // In the event of watchman recrawl (is_fresh_instance),
          // watchman subscription returns a full set of files within the
          // watched directory. After pruning with input/excluded directories,
          // the file could have been created/modified.
          // Using the cached size/mtime information, only cache the file if
          // the file doesn't exist or the file exists and one of or both
          // size/mtime is different.


          if (result.is_fresh_instance && exists) {
            const existingFile = graphQLFileMap.get(filePath); // Same size/mtime means the file stayed the same

            if (existingFile && existingFile.size === size && existingFile.mtime === mtime) {
              return;
            }

            const fileAndContent = await this.promiseToReadGraphQLFile(filePath);
            graphQLFileMap.set(filePath, { ...fileAndContent,
              size,
              mtime
            }); // Otherwise, create/update the cache with the updated file and
            // content, or delete the cache if (!exists)
          } else {
            if (graphQLFileMap) {
              this._graphQLFileListCache.set(rootDir, (await this._updateGraphQLFileListCache(graphQLFileMap, {
                size,
                mtime
              }, filePath, exists)));
            }

            this.updateFragmentDefinitionCache(rootDir, filePath, exists);
            this.updateObjectTypeDefinitionCache(rootDir, filePath, exists);
          }
        });
      }
    });

    _defineProperty(this, "_readFilesFromInputDirs", (rootDir, includes) => {
      let pattern;

      if (includes.length === 0) {
        return Promise.resolve([]);
      } // See https://github.com/graphql/graphql-language-service/issues/221
      // for details on why special handling is required here for the
      // includes.length === 1 case.


      if (includes.length === 1) {
        pattern = includes[0];
      } else {
        pattern = `{${includes.join(',')}}`;
      }

      return new Promise((resolve, reject) => {
        const globResult = new _glob.default.Glob(pattern, {
          cwd: rootDir,
          stat: true,
          absolute: false,
          ignore: ['generated/relay', '**/__flow__/**', '**/__generated__/**', '**/__github__/**', '**/__mocks__/**', '**/node_modules/**', '**/__flowtests__/**']
        }, (error, results) => {
          if (error) {
            reject(error);
          }
        });
        globResult.on('end', () => {
          resolve(Object.keys(globResult.statCache).filter(filePath => typeof globResult.statCache[filePath] === 'object').map(filePath => ({
            filePath,
            mtime: Math.trunc(globResult.statCache[filePath].mtime.getTime() / 1000),
            size: globResult.statCache[filePath].size
          })));
        });
      });
    });

    _defineProperty(this, "getSchema", async (appName, queryHasExtensions = false) => {
      const projectConfig = this._graphQLConfig.getProjectConfig(appName);

      if (!projectConfig) {
        return null;
      }

      const schemaPath = projectConfig.schemaPath;

      const endpointInfo = this._getDefaultEndpoint(projectConfig);

      const {
        endpointKey,
        schemaKey
      } = this._getSchemaCacheKeysForProject(projectConfig);

      let schemaCacheKey = null;
      let schema = null;

      if (endpointInfo && endpointKey) {
        const {
          endpoint
        } = endpointInfo;
        schemaCacheKey = endpointKey; // Maybe use cache

        if (this._schemaMap.has(schemaCacheKey)) {
          schema = this._schemaMap.get(schemaCacheKey);
          return schema && queryHasExtensions ? this._extendSchema(schema, schemaPath, schemaCacheKey) : schema;
        } // Read schema from network


        try {
          schema = await endpoint.resolveSchema();
        } catch (failure) {// Never mind
        }
      }

      if (!schema && schemaPath && schemaKey) {
        schemaCacheKey = schemaKey; // Maybe use cache

        if (this._schemaMap.has(schemaCacheKey)) {
          schema = this._schemaMap.get(schemaCacheKey);
          return schema && queryHasExtensions ? this._extendSchema(schema, schemaPath, schemaCacheKey) : schema;
        } // Read from disk


        schema = projectConfig.getSchema();
      }

      const customDirectives = projectConfig.extensions.customDirectives;

      if (customDirectives && schema) {
        const directivesSDL = customDirectives.join('\n\n');
        schema = (0, _graphql.extendSchema)(schema, (0, _graphql.parse)(directivesSDL, {
          allowLegacySDLImplementsInterfaces: true,
          allowLegacySDLEmptyFields: true
        }));
      }

      if (!schema) {
        return null;
      }

      if (this._graphQLFileListCache.has(this._configDir)) {
        schema = this._extendSchema(schema, schemaPath, schemaCacheKey);
      }

      if (schemaCacheKey) {
        this._schemaMap.set(schemaCacheKey, schema);
      }

      return schema;
    });

    _defineProperty(this, "readAllGraphQLFiles", async list => {
      const queue = list.slice(); // copy

      const responses = [];

      while (queue.length) {
        const chunk = queue.splice(0, MAX_READS);
        const promises = chunk.map(fileInfo => this.promiseToReadGraphQLFile(fileInfo.filePath).catch(error => {
          /**
           * fs emits `EMFILE | ENFILE` error when there are too many
           * open files - this can cause some fragment files not to be
           * processed.  Solve this case by implementing a queue to save
           * files failed to be processed because of `EMFILE` error,
           * and await on Promises created with the next batch from the
           * queue.
           */
          if (error.code === 'EMFILE' || error.code === 'ENFILE') {
            queue.push(fileInfo);
          }
        }).then(response => responses.push({ ...response,
          mtime: fileInfo.mtime,
          size: fileInfo.size
        })));
        await Promise.all(promises); // eslint-disable-line no-await-in-loop
      }

      return this.processGraphQLFiles(responses);
    });

    _defineProperty(this, "processGraphQLFiles", responses => {
      const objectTypeDefinitions = new Map();
      const fragmentDefinitions = new Map();
      const graphQLFileMap = new Map();
      responses.forEach(response => {
        const {
          filePath,
          content,
          asts,
          mtime,
          size
        } = response;

        if (asts) {
          asts.forEach(ast => {
            ast.definitions.forEach(definition => {
              if (definition.kind === FRAGMENT_DEFINITION) {
                fragmentDefinitions.set(definition.name.value, {
                  filePath,
                  content,
                  definition
                });
              }

              if (definition.kind === OBJECT_TYPE_DEFINITION || definition.kind === INPUT_OBJECT_TYPE_DEFINITION || definition.kind === ENUM_TYPE_DEFINITION) {
                objectTypeDefinitions.set(definition.name.value, {
                  filePath,
                  content,
                  definition
                });
              }
            });
          });
        } // Relay the previous object whether or not ast exists.


        graphQLFileMap.set(filePath, {
          filePath,
          content,
          asts,
          mtime,
          size
        });
      });
      return {
        objectTypeDefinitions,
        fragmentDefinitions,
        graphQLFileMap
      };
    });

    _defineProperty(this, "promiseToReadGraphQLFile", filePath => {
      return new Promise((resolve, reject) => _fs.default.readFile(filePath, 'utf8', (error, content) => {
        if (error) {
          reject(error);
          return;
        }

        const asts = [];
        let queries = [];

        if (content.trim().length !== 0) {
          try {
            queries = (0, _MessageProcessor.getQueryAndRange)(content, filePath);

            if (queries.length === 0) {
              // still resolve with an empty ast
              resolve({
                filePath,
                content,
                asts: [],
                queries: []
              });
              return;
            }

            queries.forEach(({
              query
            }) => asts.push((0, _graphql.parse)(query, {
              allowLegacySDLImplementsInterfaces: true,
              allowLegacySDLEmptyFields: true
            })));
          } catch (_) {
            // If query has syntax errors, go ahead and still resolve
            // the filePath and the content, but leave ast empty.
            resolve({
              filePath,
              content,
              asts: [],
              queries: []
            });
            return;
          }
        }

        resolve({
          filePath,
          content,
          asts,
          queries
        });
      }));
    });

    this._configDir = configDir;
    this._graphQLConfig = graphQLConfig;
    this._graphQLFileListCache = new Map();
    this._schemaMap = new Map();
    this._fragmentDefinitionsCache = new Map();
    this._typeDefinitionsCache = new Map();
    this._typeExtensionMap = new Map();
  }

  async _updateGraphQLFileListCache(graphQLFileMap, metrics, filePath, exists) {
    const fileAndContent = exists ? await this.promiseToReadGraphQLFile(filePath) : null;
    const existingFile = graphQLFileMap.get(filePath); // 3 cases for the cache invalidation: create/modify/delete.
    // For create/modify, swap the existing entry if available;
    // otherwise, just push in the new entry created.
    // For delete, check `exists` and splice the file out.

    if (existingFile && !exists) {
      graphQLFileMap.delete(filePath);
    } else if (fileAndContent) {
      const graphQLFileInfo = { ...fileAndContent,
        ...metrics
      };
      graphQLFileMap.set(filePath, graphQLFileInfo);
    }

    return graphQLFileMap;
  }

  async updateFragmentDefinition(rootDir, filePath, contents) {
    const cache = this._fragmentDefinitionsCache.get(rootDir);

    const asts = contents.map(({
      query
    }) => {
      try {
        return {
          ast: (0, _graphql.parse)(query, {
            allowLegacySDLImplementsInterfaces: true,
            allowLegacySDLEmptyFields: true
          }),
          query
        };
      } catch (error) {
        return {
          ast: null,
          query
        };
      }
    });

    if (cache) {
      // first go through the fragment list to delete the ones from this file
      cache.forEach((value, key) => {
        if (value.filePath === filePath) {
          cache.delete(key);
        }
      });
      asts.forEach(({
        ast,
        query
      }) => {
        if (!ast) {
          return;
        }

        ast.definitions.forEach(definition => {
          if (definition.kind === FRAGMENT_DEFINITION) {
            cache.set(definition.name.value, {
              filePath,
              content: query,
              definition
            });
          }
        });
      });
    }
  }

  async updateFragmentDefinitionCache(rootDir, filePath, exists) {
    const fileAndContent = exists ? await this.promiseToReadGraphQLFile(filePath) : null; // In the case of fragment definitions, the cache could just map the
    // definition name to the parsed ast, whether or not it existed
    // previously.
    // For delete, remove the entry from the set.

    if (!exists) {
      const cache = this._fragmentDefinitionsCache.get(rootDir);

      if (cache) {
        cache.delete(filePath);
      }
    } else if (fileAndContent && fileAndContent.queries) {
      this.updateFragmentDefinition(rootDir, filePath, fileAndContent.queries);
    }
  }

  async updateObjectTypeDefinition(rootDir, filePath, contents) {
    const cache = this._typeDefinitionsCache.get(rootDir);

    const asts = contents.map(({
      query
    }) => {
      try {
        return {
          ast: (0, _graphql.parse)(query, {
            allowLegacySDLImplementsInterfaces: true,
            allowLegacySDLEmptyFields: true
          }),
          query
        };
      } catch (error) {
        return {
          ast: null,
          query
        };
      }
    });

    if (cache) {
      // first go through the types list to delete the ones from this file
      cache.forEach((value, key) => {
        if (value.filePath === filePath) {
          cache.delete(key);
        }
      });
      asts.forEach(({
        ast,
        query
      }) => {
        if (!ast) {
          return;
        }

        ast.definitions.forEach(definition => {
          if (definition.kind === OBJECT_TYPE_DEFINITION || definition.kind === INPUT_OBJECT_TYPE_DEFINITION || definition.kind === ENUM_TYPE_DEFINITION) {
            cache.set(definition.name.value, {
              filePath,
              content: query,
              definition
            });
          }
        });
      });
    }
  }

  async updateObjectTypeDefinitionCache(rootDir, filePath, exists) {
    const fileAndContent = exists ? await this.promiseToReadGraphQLFile(filePath) : null; // In the case of type definitions, the cache could just map the
    // definition name to the parsed ast, whether or not it existed
    // previously.
    // For delete, remove the entry from the set.

    if (!exists) {
      const cache = this._typeDefinitionsCache.get(rootDir);

      if (cache) {
        cache.delete(filePath);
      }
    } else if (fileAndContent && fileAndContent.queries) {
      this.updateObjectTypeDefinition(rootDir, filePath, fileAndContent.queries);
    }
  }

  _extendSchema(schema, schemaPath, schemaCacheKey) {
    const graphQLFileMap = this._graphQLFileListCache.get(this._configDir);

    const typeExtensions = [];

    if (!graphQLFileMap) {
      return schema;
    }

    graphQLFileMap.forEach(({
      filePath,
      asts
    }) => {
      asts.forEach(ast => {
        if (filePath === schemaPath) {
          return;
        }

        ast.definitions.forEach(definition => {
          switch (definition.kind) {
            case OBJECT_TYPE_DEFINITION:
            case INTERFACE_TYPE_DEFINITION:
            case ENUM_TYPE_DEFINITION:
            case UNION_TYPE_DEFINITION:
            case SCALAR_TYPE_DEFINITION:
            case INPUT_OBJECT_TYPE_DEFINITION:
            case SCALAR_TYPE_EXTENSION:
            case OBJECT_TYPE_EXTENSION:
            case INTERFACE_TYPE_EXTENSION:
            case UNION_TYPE_EXTENSION:
            case ENUM_TYPE_EXTENSION:
            case INPUT_OBJECT_TYPE_EXTENSION:
            case DIRECTIVE_DEFINITION:
              typeExtensions.push(definition);
              break;
          }
        });
      });
    });

    if (schemaCacheKey) {
      const sorted = typeExtensions.sort((a, b) => {
        const aName = a.definition ? a.definition.name.value : a.name.value;
        const bName = b.definition ? b.definition.name.value : b.name.value;
        return aName > bName ? 1 : -1;
      });
      const hash = (0, _stringToHash.default)(JSON.stringify(sorted));

      if (this._typeExtensionMap.has(schemaCacheKey) && this._typeExtensionMap.get(schemaCacheKey) === hash) {
        return schema;
      }

      this._typeExtensionMap.set(schemaCacheKey, hash);
    }

    return (0, _graphql.extendSchema)(schema, {
      kind: DOCUMENT,
      definitions: typeExtensions
    });
  }

  _invalidateSchemaCacheForProject(projectConfig) {
    const {
      endpointKey,
      schemaKey
    } = this._getSchemaCacheKeysForProject(projectConfig);

    endpointKey && this._schemaMap.delete(endpointKey);
    schemaKey && this._schemaMap.delete(schemaKey);
  }

  _getSchemaCacheKeysForProject(projectConfig) {
    const endpointInfo = this._getDefaultEndpoint(projectConfig);

    const projectName = this._getProjectName(projectConfig);

    return {
      endpointKey: endpointInfo ? `${endpointInfo.endpointName}:${projectName}` : null,
      schemaKey: projectConfig.schemaPath ? `${projectConfig.schemaPath}:${projectName}` : null
    };
  }

  _getProjectName(projectConfig) {
    return projectConfig || 'undefinedName';
  }

  _getDefaultEndpoint(projectConfig) {
    // Jumping through hoops to get the default endpoint by name (needed for cache key)
    const endpointsExtension = projectConfig.endpointsExtension;

    if (!endpointsExtension) {
      return null;
    }

    const defaultRawEndpoint = endpointsExtension.getRawEndpoint();
    const rawEndpointsMap = endpointsExtension.getRawEndpointsMap();
    const endpointName = Object.keys(rawEndpointsMap).find(name => rawEndpointsMap[name] === defaultRawEndpoint);

    if (!endpointName) {
      return null;
    }

    return {
      endpointName,
      endpoint: endpointsExtension.getEndpoint(endpointName)
    };
  }
  /**
   * Given a list of GraphQL file metadata, read all files collected from watchman
   * and create fragmentDefinitions and GraphQL files cache.
   */


}

exports.GraphQLCache = GraphQLCache;